# Лабораторные работы №2-4

### Основное техническое задание:

---

- Запрещена стандартная библиотека управления памятью (STL, `std::vector` и т.д.)
- Вся динамическая память через операторы `new` и `delete[]`
- Вместо *индексирования* массивов использовать **арифмиетику указателей**

---

## Моя библиотека dynArray.h

Для удобства работы с памятью и массивами в лабораторных работах 2-4 я решил написать свою собственную мини-библиотеку, которая реализует динамический массив `Array<T>`, с поддержкой любого типа данных благодаря шаблонному программированию.  

#### Возможности `Array<T>`:

- Автоматическое управление динамической памятью (конструкторы и деструктор, глубокое копирование, `pushBack` с авторасширением массива, `getSize`, `getCapacity`)
- Поддержка любого типа данных
- Индексирование с помощью арифметики указателей благодаря перегрузке оператора `operator[]`
- Можно использовать как обычный массив, без авторасширения, если задать размер вручную (методы `resize`, `at`)

# Лабораторная работа №2-3

В ней я использовал для работы с памятью только свою написанную библиотеку, которая не является стандартной, со всеми реализациями управления динамической памятью, индексацией посредством арифметики указателей.

Сигнатуры функций были немного отредактированы в соответствии с возможностями моей библиотеки `dynArray.h` и класса `Array`:
<pre><code>void          inputData(Array<float>& array);
float         average(const Array<float>& array);
float         minValue(const Array<float>& array);
float         maxValue(const Array<float>& array);
Array\<float>  filterAboveAverage(const Array<float>& array);<code/><pre/>